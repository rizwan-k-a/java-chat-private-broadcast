â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    KEY CODE SNIPPETS - SYNCHRONIZATION
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


ğŸ“Œ 1. SERVER THREAD SYNCHRONIZATION (ChatServer.java)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Concurrent Client Storage:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ private ConcurrentHashMap<String, ClientHandler> clients;                   â”‚
â”‚ private ReentrantLock lock;                                                  â”‚
â”‚                                                                              â”‚
â”‚ This ensures:                                                               â”‚
â”‚ âœ“ Thread-safe client registration/removal                                  â”‚
â”‚ âœ“ No lost updates when multiple threads access simultaneously               â”‚
â”‚ âœ“ Atomic get-modify-put operations                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


Synchronized Message Broadcasting:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ public void broadcastMessage(String message, String sender) {               â”‚
â”‚     lock.lock();                                                             â”‚
â”‚     try {                                                                    â”‚
â”‚         String timestamp = LocalTime.now().format(timeFormatter);           â”‚
â”‚         String formattedMessage = "[" + timestamp + "] " + sender +        â”‚
â”‚                                   ": " + message;                           â”‚
â”‚                                                                              â”‚
â”‚         logToConsole(formattedMessage);                                      â”‚
â”‚         messageHistory.add(formattedMessage);  // thread-safe list          â”‚
â”‚         totalMessages++;                       // atomic increment           â”‚
â”‚                                                                              â”‚
â”‚         // Critical section: Send to ALL clients atomically                 â”‚
â”‚         for (ClientHandler client : clients.values()) {                    â”‚
â”‚             client.sendMessage(formattedMessage);                           â”‚
â”‚         }                                                                    â”‚
â”‚         updateStats();                                                       â”‚
â”‚     } finally {                                                              â”‚
â”‚         lock.unlock();                                                       â”‚
â”‚     }                                                                        â”‚
â”‚ }                                                                            â”‚
â”‚                                                                              â”‚
â”‚ This ensures:                                                               â”‚
â”‚ âœ“ No partial message broadcasts                                            â”‚
â”‚ âœ“ All clients receive message atomically                                   â”‚
â”‚ âœ“ Message history stays consistent                                         â”‚
â”‚ âœ“ Stats counter never corrupted                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


Synchronized Active Users Broadcast:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ public void broadcastActiveUsers() {                                         â”‚
â”‚     lock.lock();                                                             â”‚
â”‚     try {                                                                    â”‚
â”‚         Set<String> activeUsers = clients.keySet();                         â”‚
â”‚         StringBuilder userList = new StringBuilder();                        â”‚
â”‚                                                                              â”‚
â”‚         for (String user : activeUsers) {                                   â”‚
â”‚             if (userList.length() > 0) userList.append(", ");              â”‚
â”‚             userList.append(user);                                          â”‚
â”‚         }                                                                    â”‚
â”‚                                                                              â”‚
â”‚         String activeUsersMessage = "=== ACTIVE USERS (" +                â”‚
â”‚             activeUsers.size() + "): " + userList.toString() + " ===";     â”‚
â”‚         logToConsole(activeUsersMessage);                                    â”‚
â”‚                                                                              â”‚
â”‚         // Send to ALL clients atomically                                   â”‚
â”‚         for (ClientHandler client : clients.values()) {                    â”‚
â”‚             client.sendActiveUsers(new ArrayList<>(activeUsers));          â”‚
â”‚         }                                                                    â”‚
â”‚     } finally {                                                              â”‚
â”‚         lock.unlock();                                                       â”‚
â”‚     }                                                                        â”‚
â”‚ }                                                                            â”‚
â”‚                                                                              â”‚
â”‚ This ensures:                                                               â”‚
â”‚ âœ“ All clients get consistent user list                                     â”‚
â”‚ âœ“ No partial/stale user lists sent                                         â”‚
â”‚ âœ“ Atomic snapshot of active clients                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


ClientHandler - Per-Client Thread:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ public class ClientHandler extends Thread {                                  â”‚
â”‚     private Socket socket;                                                   â”‚
â”‚     private String username;                                                 â”‚
â”‚     private BufferedReader in;                                              â”‚
â”‚     private PrintWriter out;                                                â”‚
â”‚     private volatile boolean isActive = true;  // volatile for visibility   â”‚
â”‚                                                                              â”‚
â”‚     @Override                                                                â”‚
â”‚     public void run() {                                                      â”‚
â”‚         try {                                                                â”‚
â”‚             String message;                                                  â”‚
â”‚             // Each client handled in its own thread                        â”‚
â”‚             while (isActive && (message = in.readLine()) != null) {        â”‚
â”‚                 if (message.startsWith("EXIT")) break;                      â”‚
â”‚                 // Broadcast using synchronized method                      â”‚
â”‚                 broadcastMessage(message, username);                        â”‚
â”‚             }                                                                â”‚
â”‚         } catch (IOException e) {                                           â”‚
â”‚             // Client disconnected                                           â”‚
â”‚         } finally {                                                          â”‚
â”‚             disconnect();  // Cleanup                                        â”‚
â”‚         }                                                                    â”‚
â”‚     }                                                                        â”‚
â”‚                                                                              â”‚
â”‚     private void disconnect() {                                              â”‚
â”‚         isActive = false;                                                    â”‚
â”‚         try {                                                                â”‚
â”‚             socket.close();                                                  â”‚
â”‚             in.close();                                                      â”‚
â”‚             out.close();                                                     â”‚
â”‚         } catch (IOException e) { }                                         â”‚
â”‚         removeClient(username);  // Synchronized removal                    â”‚
â”‚     }                                                                        â”‚
â”‚ }                                                                            â”‚
â”‚                                                                              â”‚
â”‚ This ensures:                                                               â”‚
â”‚ âœ“ Each client handled concurrently without blocking others                 â”‚
â”‚ âœ“ Proper resource cleanup on disconnect                                    â”‚
â”‚ âœ“ volatile flag ensures other threads see disconnect                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


ğŸ“Œ 2. CLIENT THREAD SYNCHRONIZATION (ChatClient.java)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Client-Side Lock for Message Sending:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ private ReentrantLock lock;                                                  â”‚
â”‚ private volatile boolean connected = false;                                 â”‚
â”‚                                                                              â”‚
â”‚ private void sendMessage() {                                                 â”‚
â”‚     if (!connected) return;  // Check connection status (volatile read)      â”‚
â”‚                                                                              â”‚
â”‚     String message = messageInput.getText().trim();                         â”‚
â”‚     if (!message.isEmpty()) {                                                â”‚
â”‚         lock.lock();                                                         â”‚
â”‚         try {                                                                â”‚
â”‚             out.println(message);              // Critical section           â”‚
â”‚             messageInput.setText("");          // UI update in lock         â”‚
â”‚         } finally {                                                          â”‚
â”‚             lock.unlock();                                                   â”‚
â”‚         }                                                                    â”‚
â”‚     }                                                                        â”‚
â”‚ }                                                                            â”‚
â”‚                                                                              â”‚
â”‚ This ensures:                                                               â”‚
â”‚ âœ“ No two threads send simultaneously (corrupting stream)                    â”‚
â”‚ âœ“ Message input field only cleared after sending                           â”‚
â”‚ âœ“ No race between connected check and send                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


Thread-Safe Table Updates:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ private void addMessageToTable(String time, String user, String message) {  â”‚
â”‚     lock.lock();                                                             â”‚
â”‚     try {                                                                    â”‚
â”‚         tableModel.addRow(new Object[]{time, user, message});              â”‚
â”‚         int lastRow = chatTable.getRowCount() - 1;                          â”‚
â”‚         chatTable.scrollRectToVisible(chatTable.getCellRect(lastRow,      â”‚
â”‚                                       0, true));                            â”‚
â”‚     } finally {                                                              â”‚
â”‚         lock.unlock();                                                       â”‚
â”‚     }                                                                        â”‚
â”‚ }                                                                            â”‚
â”‚                                                                              â”‚
â”‚ This ensures:                                                               â”‚
â”‚ âœ“ Table model updated atomically                                           â”‚
â”‚ âœ“ Scroll position consistent with last row                                 â”‚
â”‚ âœ“ No incomplete row additions                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


Thread-Safe GUI Updates via EDT:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ private void updateActiveUsers(int count, String userList) {               â”‚
â”‚     SwingUtilities.invokeLater(() -> {  // Run on EDT (Event Dispatch Thread)â”‚
â”‚         activeUsersLabel.setText("Active Users (" + count + "): " +        â”‚
â”‚                                  userList);                                 â”‚
â”‚     });                                                                      â”‚
â”‚ }                                                                            â”‚
â”‚                                                                              â”‚
â”‚ This ensures:                                                               â”‚
â”‚ âœ“ All GUI updates on single EDT thread                                     â”‚
â”‚ âœ“ No concurrent modifications to GUI components                            â”‚
â”‚ âœ“ No race conditions in Swing                                              â”‚
â”‚ âœ“ GUI remains responsive                                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


MessageListener - Async Message Reception:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ private class MessageListener extends Thread {                              â”‚
â”‚     @Override                                                                â”‚
â”‚     public void run() {                                                      â”‚
â”‚         try {                                                                â”‚
â”‚             String message;                                                  â”‚
â”‚             // Runs in separate thread, doesn't block UI                    â”‚
â”‚             while (connected && (message = in.readLine()) != null) {       â”‚
â”‚                 final String receivedMessage = message;                     â”‚
â”‚                                                                              â”‚
â”‚                 // Handle active users update                               â”‚
â”‚                 if (receivedMessage.startsWith("USERS:")) {                â”‚
â”‚                     String[] parts = receivedMessage.split(":", 3);         â”‚
â”‚                     if (parts.length == 3) {                                â”‚
â”‚                         int userCount = Integer.parseInt(parts[1]);         â”‚
â”‚                         String users = parts[2].isEmpty() ? "None" :        â”‚
â”‚                                         parts[2].replace(",", ", ");        â”‚
â”‚                         updateActiveUsers(userCount, users);                â”‚
â”‚                     }                                                        â”‚
â”‚                 }                                                            â”‚
â”‚                                                                              â”‚
â”‚                 // Handle regular messages                                  â”‚
â”‚                 else if (receivedMessage.startsWith("[")) {                 â”‚
â”‚                     // Parse: [HH:mm:ss] Username: Message                 â”‚
â”‚                     int closeIdx = receivedMessage.indexOf("]");            â”‚
â”‚                     if (closeIdx > 0) {                                     â”‚
â”‚                         String time = receivedMessage.substring(1,         â”‚
â”‚                                       closeIdx);                            â”‚
â”‚                         String rest = receivedMessage.substring(          â”‚
â”‚                                       closeIdx + 2);                        â”‚
â”‚                         int colonIdx = rest.indexOf(": ");                  â”‚
â”‚                         if (colonIdx > 0) {                                 â”‚
â”‚                             String user = rest.substring(0, colonIdx);      â”‚
â”‚                             String msg = rest.substring(colonIdx + 2);      â”‚
â”‚                             addMessageToTable(time, user, msg);            â”‚
â”‚                         }                                                    â”‚
â”‚                     }                                                        â”‚
â”‚                 }                                                            â”‚
â”‚             }                                                                â”‚
â”‚         } catch (IOException e) {                                           â”‚
â”‚             // Connection closed                                             â”‚
â”‚         } finally {                                                          â”‚
â”‚             // Cleanup on disconnect                                         â”‚
â”‚             connected = false;                                              â”‚
â”‚             SwingUtilities.invokeLater(() -> {                              â”‚
â”‚                 statusLabel.setText("Status: Disconnected");               â”‚
â”‚                 messageInput.setEnabled(false);                             â”‚
â”‚             });                                                              â”‚
â”‚         }                                                                    â”‚
â”‚     }                                                                        â”‚
â”‚ }                                                                            â”‚
â”‚                                                                              â”‚
â”‚ This ensures:                                                               â”‚
â”‚ âœ“ Message receiving doesn't block UI (separate thread)                     â”‚
â”‚ âœ“ Multiple messages processed concurrently                                 â”‚
â”‚ âœ“ GUI updates always on EDT                                                â”‚
â”‚ âœ“ Proper cleanup on disconnection                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


ğŸ“Œ 3. SYNCHRONIZATION MECHANISMS SUMMARY
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

1. ReentrantLock (Explicit Locking)
   Usage: Critical sections with complex logic
   Example: broadcastMessage(), sendMessage()
   Benefit: Fine-grained control, multiple tries possible

2. ConcurrentHashMap (Concurrent Collections)
   Usage: Concurrent read/write to client map
   Example: clients.put(), clients.values(), clients.remove()
   Benefit: No explicit locking needed for these ops

3. Collections.synchronizedList (Synchronized Collections)
   Usage: Message history
   Example: messageHistory.add()
   Benefit: Thread-safe list operations

4. volatile boolean (Memory Visibility)
   Usage: Connection flags
   Example: connected, running, isActive
   Benefit: Ensures visibility across threads

5. SwingUtilities.invokeLater() (Event Dispatch Thread)
   Usage: All GUI updates
   Example: statusLabel.setText(), addMessageToTable()
   Benefit: GUI thread safety, no race conditions

6. Try-Finally Blocks (Resource Management)
   Usage: Lock release, socket closure
   Example: lock.lock(); try { ... } finally { lock.unlock(); }
   Benefit: Ensures cleanup even if exception occurs


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


ğŸ“Œ 4. THREAD EXECUTION FLOW
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

SERVER SIDE:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Main Thread (Main Method)
  â””â”€ SwingUtilities.invokeLater(() -> new ChatServer())
       â””â”€ ChatServer constructor
            â”œâ”€ setupGUI()          â†’ Creates GUI on EDT
            â””â”€ startServer()
                 â””â”€ New Thread (accepts connections)
                      â””â”€ while(running) ServerSocket.accept()
                           â”œâ”€ New Thread (Client1)
                           â”‚    â””â”€ ClientHandler1.run()
                           â”‚         â””â”€ while(connected) readLine()
                           â”‚              â””â”€ broadcastMessage() [LOCKED]
                           â”‚
                           â”œâ”€ New Thread (Client2)
                           â”‚    â””â”€ ClientHandler2.run()
                           â”‚         â””â”€ while(connected) readLine()
                           â”‚              â””â”€ broadcastMessage() [LOCKED]
                           â”‚
                           â””â”€ New Thread (Client3)
                                â””â”€ ClientHandler3.run()
                                     â””â”€ while(connected) readLine()
                                          â””â”€ broadcastMessage() [LOCKED]


CLIENT SIDE:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Main Thread
  â””â”€ SwingUtilities.invokeLater(() -> new ChatClient())
       â””â”€ ChatClient constructor
            â”œâ”€ setupGUI()        â†’ Creates GUI on EDT
            â””â”€ connectToServer()
                 â””â”€ New Thread (connection setup)
                      â”œâ”€ Username dialog
                      â”œâ”€ Socket connection
                      â”œâ”€ Send username to server
                      â”‚
                      â””â”€ New Thread (MessageListener)
                           â””â”€ while(connected) readLine()
                                â””â”€ Parse message
                                     â””â”€ SwingUtilities.invokeLater()
                                          â””â”€ addMessageToTable() [LOCKED]

User Interface Thread (Event Dispatch Thread - EDT)
  â””â”€ Handles all GUI updates from SwingUtilities.invokeLater()
  â””â”€ Handles button clicks and key events


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


ğŸ“Œ 5. RACE CONDITION PREVENTION
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Potential Race Condition 1: Concurrent Client List Modifications
â”‚ Server Thread A: clients.put("User1", handler1)
â”‚ Server Thread B: clients.values() [iterating for broadcast]
â”‚ Server Thread C: clients.remove("User2")
â””â”€ Solution: ReentrantLock protects broadcastMessage() + broadcastActiveUsers()
   â””â”€ ConcurrentHashMap handles atomic operations


Potential Race Condition 2: Stream Corruption
â”‚ Client Thread A: out.println("Message A")
â”‚ Client Thread B: out.println("Message B")
â”‚ Result: Mixed: "Message A Message B" (corrupted)
â””â”€ Solution: ReentrantLock in sendMessage() prevents simultaneous writes


Potential Race Condition 3: GUI Update During Table Modification
â”‚ MessageListener Thread: tableModel.addRow()
â”‚ User Input Thread: messageInput.setText("")
â”‚ EDT Thread: Rendering table
â””â”€ Solution: SwingUtilities.invokeLater() + ReentrantLock in addMessageToTable()


Potential Race Condition 4: Connection Flag Check
â”‚ Main Thread: if (!connected) return;
â”‚ MessageListener Thread: connected = false;
â”‚ Race: Check and send without connected becoming false
â””â”€ Solution: volatile boolean ensures immediate visibility


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
